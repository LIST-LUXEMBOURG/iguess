<h1>Register Datasets</h1>

<div id="error-list" class="explanation-problem" style="display: none"></div>

<div class="explanation">
  <p>iGUESS uses datasets stored on remote servers.  To register datasets with the system, 
    enter a server URL in the box below. iGUESS will probe the remote server and present 
    you a list of datasets you can register.  In order to use a dataset with a module, 
    you will need to tag it with the appropriate tags.  If you want to use the dataset 
    for mapping purposes, use the Mapping tag.</p>

  <p>iGUESS will probe for WFS, WCS, and WMS servers at the URL provided below.  Layers 
    offered by the WMS will be available for mapping, and layers offered by the WFS/WCS 
    will be available for using as inputs to web processes.</p>
</div>


<%= render :partial => 'shared/server_url_entry_control.html.erb' %>


<div class="services-display">

  <div class="progress-container">
    <span class="probing" id="probing-wms">Probing WMS server...
      <span class="loading_indicator"></span>
    </span>
    <span class="probing" id="probing-wfs">Probing WFS server...
      <span class="loading_indicator"></span>
    </span>
    <span class="probing" id="probing-wcs">Probing WCS server...
      <span class="loading_indicator"></span>
    </span>
  </div>

  <div class="server-info">
    <div class="server-name" id="server-name"></div>
    <div class="server-descr" id="server-descr"></div>
    <div class="server-owner" id="server-owner"></div>
    <div id="results-display"><!-- Search results will be shown here --></div>
  </div>


  <div class="infotable" id="infotable-unavailable-for-mapping">
    <h1 class="dataset-title">Available for mapping</h1>
      <div>
        We do all our mapping using <%= GoogleProjection %>, which is compatible with 
        Google Maps and OpenStreetMap, used as a background in the map window.  If a 
        dataset is available from a WMS service, and is in this projection, then 
        we can display it on our maps.
      </div>
      <br>
    <h1 class="dataset-title">Available for processing</h1>
    <div>
      Each city defines a projection that will be used for all calculations.  
      For <%= @current_city.name %>, that is <%= @current_city.srs %>.  If a dataset 
      is available from a WFS or WCS server, and is in this projection, then we can 
      use it in the computation modules.
    </div>
  </div>


<%= render :partial => 'tag_functions.html.erb' %>

<script>

  // Add "js" style to body -- makes fancy checkboxes work
  $('body').attr("class",$('body').attr("class") + " js");

  var GOOGLE_SRS = '<%= GoogleProjection %>';
  var LOCAL_SRS = '<%= @current_city.srs %>';


  var wfsProcessingComplete = 0;
  var wmsProcessingComplete = 0;
  var wcsProcessingComplete = 0;  
  var regDatasetsComplete   = 0;


  var resetServiceLoadedStatus = function() {
    wfsProcessingComplete = 0;
    wmsProcessingComplete = 0;
    wcsProcessingComplete = 0;
    regDatasetsComplete   = 0;
  };


  // Called when we've gotten whatever response we're going to get from the server in question
  // i.e. when a WFS response arrives.  More responses might be coming (from WMS, and WCS, 
  // for example).
  // Note: serverInfo could be null.
  var doneProcessing = function(type, serverInfo) 
  {
    if(type == "WFS") {
      wfsProcessingComplete++;
      $("#probing-wfs").hide();
    }
    else if(type == "WMS") {
      wmsProcessingComplete++;
      $("#probing-wms").hide();
    }
    else if(type == "WCS") {
      wcsProcessingComplete++;
      if(wcsProcessingComplete == 2)
        $("#probing-wcs").hide();
    }
    else if(type == "RegisteredDatasets") {
      regDatasetsComplete++;
    }
    else { alert("Unknown service type: " + type); }

    if(serverInfo)
      displayServerDetails(serverInfo, type);   // Display this as it comes in

    // Make sure we've heard from all services before continuing
    if(wfsProcessingComplete != 1 || wmsProcessingComplete != 1 || 
       wcsProcessingComplete != 2 || regDatasetsComplete != 1)  
      return; 

    $(".progress-container").hide();
    displayServices();
  };


  // Popup a window for displaying the passed content
  var displayOverflow = function(content)
  {
    var win = window.open("", "", "width=600, height=400, scrollbars=yes");
    if(win)
    {
      $(win.document.body).html(content);
      return;
    }
    alert("Can't open new window. Please change your browser settings to allow " + 
          "popups from this site.");
  };


  var getCrsListDisplay = function(crsList, maxLen)
  {
    var len = (typeof(crsList) == "string") ? 0 : crsList.length;
    var itemCount = len;

    if(itemCount > maxLen)
      itemCount = maxLen;

    var html = "<span>";

    html += (typeof(crsList) == "string" ? crsList : 
                                           crsList.slice(0, itemCount).join('; '));

    // Set up overflow for long lists
    if(len > itemCount)
    {
      html += " <a href='#' " + 
                  "onclick='displayOverflow(\"Full list of CRSs supported for this dataset:<br>" +
               crsList.join('; ') +  "\");return false;'>More &gt;&gt;</a>";
    }

    html += "</span>";
    return html;
  };


   // Only used below
  var makeTagListContainer = function(urlId, contents1, contents2)
  {
    return '<span class="folder-taglist-deletable-' + urlId + ' taglist">' + contents1 + '</span>' +
           '<span class="taglist-deletable-'        + urlId + ' taglist">' + contents2 + '</span>';
  };


  // Generate a tag list for the specified layer
  // regLyr is an object that has tags and folder_tags fields
  var makeTagList = function(layer, regLyr, urlId) 
  {
    if(!regLyr)
      return makeTagListContainer(urlId, "", "");    // Layer not registered

    if(!regLyr.tags && !regLyr.folder_tags)
      return makeTagListContainer(urlId, "", "");    // Layer registered, but has no tags

    return makeTagListContainer(urlId,
              createTagList(regLyr.folder_tags, true, layer.serverUrl, layer.identifier, 'folder-tag'),
              createTagList(regLyr.tags,        true, layer.serverUrl, layer.identifier, 'tag'));
  };


  var createTagControl = function(layer, regLyr, urlId, tagEntryFieldName, 
                                  tagPickerControlClass)
  {
    var service;

    if(layer.type.hasObject("WCS"))
      service = "WCS";

    // If we have a WFS layer with no coordinate data, show the WCS tag list, which
    // is basically the same, but without the Area of Interest tag
    else if (layer.type.hasObject("WFS") && getCoord(layer, "left") === "")
      service = "WCS"; 
    
    else if(layer.type.hasObject("WFS")) 
      service = "WFS";

    else
      service = "WMS";

    var enabled = true && regLyr;

    return '<div class="tag-control">' +
             makeTagList(layer, regLyr, urlId) +
             createFolderTagControl(layer, tagEntryFieldName, tagPickerControlClass, enabled) +
             makeTagPickerControl(layer, tagPickerControlClass, service, enabled) +
           '</div>';
  };


  var TAG_PICKER_PREFIX = "tag-picker-";


  var displayServices = function() 
  {
    var mapId = 0;
    var first = true;

    var layerCount = Object.keys(discoveredLayers).length;

    // If no layers were loaded, show an intelligble error message and bail
    if(layerCount == 0) {
      $("#results-display").html(
        '<div class="error-header">Please check the number and dial again</div>' +
        '<div class="error-body">No data layers could be found on the specified server.<br>' +
        'Either the URL is not that of a WMS/WFS/WCS data server, or the server is not responding.' +
        '</div>');

      $(".server-info").show();

      return;
    };

    // Here we know layerCount > 0

    var tagEntryFieldNameCounter = 0;

    // We have layers!!!

    $("#results-display").html("");   // Clear the decks

    // These refer to the layers that have been discovered on the remote servers
    var discoveredLayerKeys = Object.keys(discoveredLayers).sort();


    // Render found datasets in two passes -- first for registered items, 
    // second for unregistered ones.
    // This puts registered items at the top of the screen.
    for(var pass = 0; pass < 2; pass++)
    {
      for(var lyrctr = 0, len = discoveredLayerKeys.length; lyrctr < len; lyrctr++)
      {
        var urlId = discoveredLayerKeys[lyrctr];
        var layer = discoveredLayers[urlId];      
        var regLyr = RegisteredDatasetList[layer.identifier];

        if((pass == 0 && !regLyr) || (pass == 1 && regLyr)) { continue; }

        if(first) {
          $("#results-display").html(
              "<div>Server has <span id='results-display-count'></span> " + 
              "layers.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" +
              "<span class='proj-list'>SRS required for processing: " + 
              "<span>" + LOCAL_SRS + "</span></span>; " +
              "<span class='proj-list'>SRS required for mapping: " + 
              "<span>" + GOOGLE_SRS + ".</span></span></div>" + 
              "<ul id='layer-table'></ul>");

          first = false;
        }

        var mapDivId = "map" + mapId++;

        var availableInLocalProjection  = false;
        var availableInGoogleProjection = false;

        if(layer.srs !== null) {
          availableInLocalProjection  = CRS.hasCRS(layer.dataCrs,    LOCAL_SRS);
          availableInGoogleProjection = CRS.hasCRS(layer.wmsCrsList, GOOGLE_SRS);
        }

        var titleNode = $(document.createElement("div"));
        titleNode.html("<span class='dataset_title' id='dataset-title-" + layer.identifier + "'>" + 
                          (layer.title != "" ? layer.title : layer.identifier) + 
                       "</span>" + 
                       "<span class='dataset-identifier'>Identifier: " +
                       "<span>" + layer.identifier + "</span></span>");


        var servicesAvailNode = $(document.createElement("div"));
        servicesAvailNode.attr({ class:"dataset_services_available" });
        servicesAvailNode.text("Services: " + layer.type.join(', '));

        if(regLyr) {  
          servicesAvailNode.append("<br>Used in " + regLyr.configCount + " configurations");
        }

        var abstractNode = "";

        if(layer.abstract) {
          abstractNode = $(document.createElement('div'));
          abstractNode.attr({ class:"dataset_abstract", 
                              id:   "dataset-abstract-" + layer.identifier });
          abstractNode.html(linkify(layer.abstract));
        }

        var srsNode = $(document.createElement("div"));
        srsNode.attr({ class:"dataset_srs" });

        var code = 
          '<div style="cursor:pointer" rel="#infotable-unavailable-for-mapping">' +
          '<span class="proj-background">available for mapping</span><span class="' + 
              (availableInGoogleProjection ? 'yes-background' : 'no-background') + '">' + 
              (availableInGoogleProjection ? 'yes'            : 'no')     + '</span>' +
          '</div>' +

          '<div style="cursor:pointer" rel="#infotable-unavailable-for-mapping">' +
          '<span class="proj-background">available for processing</span><span class="' + 
              (availableInLocalProjection  ? 'yes-background' : 'no-background') + '">' + 
              (availableInLocalProjection  ? 'yes'            : 'no')     + '</span>' +
          '</div>' +
          '<br><br><br>';

        srsNode.append(code);


        var data_info = $(document.createElement('div'));
        var tagPickerControlClass = TAG_PICKER_PREFIX + layer.identifier;
        
        var tagEntryFieldName = "tagEntry" + tagEntryFieldNameCounter;
        tagEntryFieldNameCounter++;

        data_info.attr({ class:'data-info' });

        data_info.append(srsNode)
                 .append(getRegisterControlHtml(layer.identifier, regLyr))
                 .append(servicesAvailNode)
                 .append(createTagControl(layer, regLyr, urlId,
                                          tagEntryFieldName, tagPickerControlClass));

        var sample_map = $(document.createElement("div"));

        // Map will be rendered based on div's id
        sample_map.attr({ id:mapDivId, class:"sample-map" });   


        var container = $(document.createElement("div"));
        container.attr({ class:"dataset" });
        container.append(titleNode)
                 .append(abstractNode)
                 .append(data_info)
                 .append(sample_map);


        var crsInfo = "<div>";

        if(layer.wmsCrsList && layer.wmsCrsList.length > 0)
          crsInfo += "<div class='proj-list'>Mapping Projections: " + 
                        getCrsListDisplay(layer.wmsCrsList, 5) + 
                     "</div>";            

        if(layer.dataCrs)
          crsInfo += "<div class='proj-list'>Processing Projections: " + 
                        getCrsListDisplay(layer.dataCrs, 5) +
                     "</div>";

        crsInfo += "</div>";

        container.append(crsInfo);

        // li_element (map-data-item)
        //    container (regLyr_dataset or unregLyr_dataset)
        //       data_info
        //       sample_map


        var li_element = $(document.createElement("li"));
        li_element.attr({ class:"map-data-item " + (regLyr ? "registered_dataset" : "unregistered_dataset") });
        li_element.append(container);

        $("#layer-table").append(li_element);

        var bb = layer.mapBbox;   

        if(!bb || !CRS.hasCRS(layer.wmsCrsList, GOOGLE_SRS)) {
          // I suspect that layer.type.hasObject('WMS') will always be false here...  Not so!
          $('#' + mapDivId).html(
                '<div class="map-unavailable">' + 
                    (layer.type.hasObject('WMS') ? 'Map unavailable' : 
                                                   'No WMS service for this layer') + 
                '</div>'
              );

          if(!alreadyShownWmsError) {
            var err = '<div>We cannot display sample maps for some datasets on this ' + 
                'server.  The most likely cause of this problem is that the server\'s WMS ' + 
                'functionality is not properly configured: either a WMS service has not ' + 
                'been defined for a particular identifier, or I cannot get a usable ' + 
                'bounding box for the layers you have requested.<P><P>You can see how the ' + 
                'server responds to WMS queries by clicking here: ' +
                '<a href="'+ WMS.getCapReq(layer.serverUrl) + '" target="_blank">' + 
                    'WMS GetCapabilities</a></div>';

            $('#error-list').append(err).slideDown(500);

            alreadyShownWmsError = true;    // Only show error message once, to avoid flooding the error display
            }
        }
        else {

          var miniMap = new OpenLayers.Map({
                  // maxExtent:  new OpenLayers.SetCenter(),
                  projection: new OpenLayers.Projection(GOOGLE_SRS),
                  controls: [ new OpenLayers.Control.NavToolbar({zoomWheelEnabled: true}) ]
          });

          var lyr = new OpenLayers.Layer.WMS(
                  layer.title,
                  Presets.getServerUrl(),
                  { layers:  layer.identifier,
                    format:  "image/gif" 
                  }
          );

          miniMap.addLayer(lyr);
          // miniMap.zoomToMaxExtent();
          var center = new OpenLayers.LonLat(<%= @current_city.mapx %>, <%= @current_city.mapy %>);
          miniMap.setCenter(center, <%= @current_city.zoom %>);

          miniMap.render(mapDivId);    // Renders to <div id="map#">
        }
      }  // end for loop
    }  // for pass = 0 to 2

    populateTagLists();
    addDeleteTagClickHander(true);    // Add delete click handler for processing tags
    addDeleteTagClickHander(false);   // Add delete click handler for folder tags
    addSwitchboxHandler();


    $('div[rel]').overlay();  // Activate availability status overlays
    $("#results-display-count").text(discoveredLayerKeys.length);    // Update layer display


    // This gets called when the ajax request to the server returns with a success message
    var registeredDataset = function(data, serverUrl, datasetIdentifier, checkbox, item)
    {
        $(".taglist-deletable-"        + urlId).attr("disabled", false);
        $(".folder-taglist-deletable-" + urlId).attr("disabled", false);

        updateTags(serverUrl, data.dataset.identifier, data.tags);
        updateFolderTags(serverUrl, data.dataset.identifier, data.folder_tags);

        onDatasetRegOrUnreg(item, checkbox, datasetIdentifier, true);
    }


    var disableTagItems = function(urlId, attr) 
    {
      $(".taglist-deletable-"        + urlId + " ." + attr + "," + 
        ".folder-taglist-deletable-" + urlId + " ." + attr).attr("disabled", true);

      $(".taglist-deletable-"        + urlId + " ." + attr + "," +
        ".folder-taglist-deletable-" + urlId + " ." + attr).off("click");   // Disable clicking
    };


    var unregisteredDataset = function(serverUrl, datasetIdentifier, checkbox, item)
    {
      var urlId = cssEscape(serverUrl + datasetIdentifier);

      disableTagItems(urlId, "tag-delete-button");
      disableTagItems(urlId, "folder-tag-delete-button");

      $(".taglist-deletable-"        + urlId + " .tag", 
        ".folder-taglist-deletable-" + urlId + " .tag").attr("disabled", true);

      $(".taglist-deletable-"        + urlId,
        ".folder-taglist-deletable-" + urlId)          .attr("disabled", true);

      onDatasetRegOrUnreg(item, checkbox, datasetIdentifier, false);
    };


    // Common code to run when we regiester or unregister a dataset
    var onDatasetRegOrUnreg = function(item, checkbox, datasetIdentifier, registering)
    {
      item.toggleClass("checked");

      // Make div red or green
      item.parent().parent().parent().toggleClass("registered_dataset");
      item.parent().parent().parent().toggleClass("unregistered_dataset");

      checkbox.checked = registering;

      // This will enable/disable both the Mapping and Processing tag dropdowns
      $('.' + TAG_PICKER_PREFIX + datasetIdentifier).attr('disabled', !registering);
    };


    // When the toggle switch is clicked, check off / de-select the associated checkbox
    // Want to find this when we search for "registered_"
    $(".toggle").click(function(e) 
    {
      var checkboxID        = $(this).attr("ref");
      var checkbox          = document.getElementById(checkboxID);
      var datasetIdentifier = getIdentifierFromCheckboxId(checkboxID);
      
      var serverUrl         = Presets.getServerUrl();

      var configCount = RegisteredDatasetList[datasetIdentifier] ?
                              RegisteredDatasetList[datasetIdentifier].configCount : 0;

      var urlId = cssEscape(serverUrl + datasetIdentifier);

      var thiiis = $(this);   // Remember "this" for when the ajax requests return

      if(checkbox.checked) {
        // ===== Unregister dataset =====

        // When unregistering a data layer that is used in a configuration, show a warning
        if(configCount > 0) {
          var c =  (configCount == 1) ? "configuration" : "configurations";
          var t =  (configCount == 1) ? "this"          : "these";
          var th = (configCount == 1) ? "it"            : "them";

          if(!confirm("This dataset is in use by " + configCount + " " + c + ". " +
                      "Unregistering it will cause it to be removed from " + t + " " + c + ".\n\n" +
                      "Click OK if you are sure you want to unregister this dataset.")) {
            e.preventDefault();
            return;
          }
        }

        // Let the server know this layer is no longer registered -- to do this we delete the corresponding
        // record in the datasets table.
        $.ajax({
          type: "DELETE",      // DELETE combined with url below triggers "destroy_by_params" action on controller
          url: '<%= url_for(:controller=>:datasets, :action=>:destroy_by_params) %>',
          data: "dataset[identifier]="  + datasetIdentifier +
                "&dataset[server_url]=" + serverUrl,

          headers: { "X-CSRF-Token": "<%= form_authenticity_token.to_s %>" },
          // http://api.jquery.com/jQuery.ajax/
          success: function(data, status, jqXHR)  { 
              unregisteredDataset(serverUrl, datasetIdentifier, checkbox, thiiis); 
            },
          error: function(jqXHR, status, error) {
              ajaxErrorHandler(jqXHR, status, error, "Could not unregister dataset!");
            }
        });

      } else {
        // ===== Register dataset =====

        var layer          = discoveredLayers[urlId];
        var taglist        = extractTagList(serverUrl, datasetIdentifier);
        var folderTagList  = extractFolderTagList(serverUrl, datasetIdentifier);
        var sanitizedIdent = sanitizeForCss(datasetIdentifier)
        var title          = $("#dataset-title-"    + sanitizedIdent).text();
        var abstract       = $("#dataset-abstract-" + sanitizedIdent).text();

        var service  = "";
        if(     layer.type.hasObject("WFS")) { service = "WFS"; }
        else if(layer.type.hasObject("WCS")) { service = "WCS"; }
        else if(layer.type.hasObject("WMS")) { service = "WMS"; }
        
        if (CRS.hasCRS(layer.dataCrs, LOCAL_SRS)) crs = LOCAL_SRS;
        else if (layer.dataCrs instanceof Array) crs = layer.dataCrs[0];
        else crs = layer.dataCrs;

        // Let the server know this layer is now registered -- to do this we must create a new record in
        // our datasets table.
        $.ajax({
          type: "POST",      // POST combined with url below triggers "create" action on controller
          url: "<%= url_for(:controller=>:datasets, :action=>:create, :format=>:json) %>",
          data: "dataset[identifier]="       + datasetIdentifier +
                "&dataset[service]="         + service +
                "&dataset[server_url]="      + serverUrl +
                "&dataset[title]="           + encodeURIComponent(title) +
                "&dataset[abstract]="        + encodeURIComponent(abstract) +
                "&dataset[bbox_left]="       + getCoord(layer, "left") +
                "&dataset[bbox_right]="      + getCoord(layer, "right") +
                "&dataset[bbox_top]="        + getCoord(layer, "top") +
                "&dataset[bbox_bottom]="     + getCoord(layer, "bottom") +
                "&dataset[bbox_srs]="        + crs +
                "&dataset[resolution_x]="    + (layer.resolution ? Math.abs(layer.resolution.x) : 0) +
                "&dataset[resolution_y]="    + (layer.resolution ? Math.abs(layer.resolution.y) : 0) +
                "&dataset[format]="          + (layer.format ? layer.format : "") +
                "&dataset[local_srs]="       + (CRS.hasCRS(layer.dataCrs, LOCAL_SRS) ? "true" : "false") +
                "&dataset[city_id]="         + "<%= raw @current_city.id %>" +
                "&dataset[alive]=true"       +

                "&server_title="             + getServerTitle() +
                "&server_abstract="          + getServerAbstract() +
                "&tags="                     + taglist +
                "&folder_tags="              + folderTagList,

          headers: { "X-CSRF-Token": "<%= form_authenticity_token.to_s %>" },
          success: function(data, status, jqXHR)  { 
            console.log(data);
              registeredDataset(data, serverUrl, datasetIdentifier, checkbox, thiiis); 
            },
          error: function(jqXHR, textStatus, error) { 
                 ajaxErrorHandler(jqXHR, status, error, "Could not register dataset!");
                }
        });
      }

      e.preventDefault();

    });  // end toggle state change handler

    
    // Because of our unusual layout, we need to manually adjust things to get equal tile sizes... lame!
    equalizeRowHeights();
    $('#layer-table').equalWidths();
  };


  // Handles both types of bounding boxes... either a simple array, or a dictionary 
  // with left/right/top/bottom keys
  // which == "left", "right", "top", or "bottom"
  var getCoord = function(layer, which)
  {
    if(layer.dataBbox)
    {
      if(layer.dataBbox[which])
        return layer.dataBbox[which];

      if(which == "left")
        return layer.dataBbox[0];
      if(which == "right")
        return layer.dataBbox[2];
      if(which == "top")
        return layer.dataBbox[3];
      if(which == "bottom")
        return layer.dataBbox[1];
    }
    return "";
  };


  var extractTagList = function(serverUrl, datasetIdentifier) 
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    var tags = [];


    $('.taglist-deletable-' + urlId).children().each(function() {
        tags.push($(this).text());
    });

    return tags;
  };


  var extractFolderTagList = function(serverUrl, datasetIdentifier) 
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    var tags = [];


    $('.folder-taglist-deletable-' + urlId).children().each(function() {
        tags.push($(this).text());
    });

    return tags;
  };


  var hideProbingIndicators = function() 
  {
    $("#probing-wms").hide();
    $("#probing-wfs").hide();
    $("#probing-wcs").hide();
    $(".progress-container").hide();
  };


  var showProbingIndicators = function() 
  {
    $("#probing-wfs").show();
    $("#probing-wms").show();
    $("#probing-wcs").show();

    $(".progress-container").show();
  };


  var getServerTitle = function()
  {
    return $("#server-name").text();
  }


  var getServerAbstract = function()
  {
    return $("#server-descr").text();
  }


  $().ready(function(){
    hideProbingIndicators();
  });


  // Adapted from http://css-tricks.com/equal-height-blocks-in-rows/
  var currentTallest = 0,
      currentRowStart = 0,
      rowDivs = new Array();


  var setConformingHeight = function(el, newHeight) 
  {
     // Set the height to something new, but remember the original height in case things change
     el.data("originalHeight", (el.data("originalHeight") == undefined) ? el.height() : 
                                                                          el.data("originalHeight"));
     el.height(newHeight);
  };


  var getOriginalHeight = function(el) 
  {
     // if the height has changed, send the originalHeight
     return (el.data("originalHeight") == undefined) ? el.height() : 
                                                       el.data("originalHeight");
  };


  var equalizeRowHeights = function() 
  {
     // Find the tallest LI in the row, and set the heights of all of the LIs to match it
     $('li.map-data-item').each(function() {
        // "caching"
        var el = $(this);
        
        var topPosition = el.position().top;

        if(currentRowStart != topPosition) {

          // We just came to a new row.  Set all the heights on the completed row.
          for(var i=0, len=rowDivs.length; i < len; i++) 
            setConformingHeight(rowDivs[i], currentTallest);

          // Set the variables for the new row
          rowDivs.length  = 0; // empty the array
          currentRowStart = topPosition;
          currentTallest  = getOriginalHeight(el);
          rowDivs.push(el);

        } else {

           // Another div on the current row.  Add it to the list and check if it's taller.
           rowDivs.push(el);
           currentTallest = (currentTallest < getOriginalHeight(el)) ? getOriginalHeight(el) : 
                                                                       currentTallest;
        }
        // Do the last row
        for (currentDiv = 0 ; currentDiv < rowDivs.length ; currentDiv++) 
          setConformingHeight(rowDivs[currentDiv], currentTallest);

     });
  };


  // Recalc heights if window size changes
  $(window).resize(function() 
  {
     equalizeRowHeights();
  });


  // Basic dataset object -- this is what we track for datasets seen on remote server
  // Used for discoveredLayers
  var Dataset = function(serverUrl, datasetInfo) 
  {
    this.serverUrl = serverUrl;

    if(datasetInfo) {
      this.identifier  = datasetInfo.name  || datasetInfo.identifier;
      this.title       = datasetInfo.title || this.identifier;
      this["abstract"] = datasetInfo.abstract;    // abstract is a js reserved word!
    } else {
      this.identifier  = ""; 
      this.title       = ""; 
      this["abstract"] = "";    // abstract is a js reserved word!
    }
  };


  var WMSDataset = function(serverUrl, datasetInfo)
  {
    Dataset.call(this, serverUrl, datasetInfo);

    this.type = ["WMS"];

    this.wmsCrs      = null;
    this.wmsCrsList  = [];      // CRSs that the map data is available in
    this.mapBbox     = null;    // Projected bounds of the map

    var localCrs = CRS.getSimpleFormat(LOCAL_SRS);

    // datasetInfo.srs[xxx] == true  ==> if this exists, the we can use localCrs
    this.wmsCrs  = datasetInfo.srs[localCrs]  && localCrs;

    for(var key in datasetInfo.srs)
      this.wmsCrsList.push(key);

    // For mapping, we always use the llbbox, which should be compatible with the "google projection"
    this.mapBbox = datasetInfo.llbbox;
  };

  WMSDataset.prototype = new Dataset;
  WMSDataset.prototype.constructor = WMSDataset; // repair the inherited constructor


  var WFSDataset = function(serverUrl, datasetInfo)
  {
    Dataset.call(this, serverUrl, datasetInfo);

    this.type = ["WFS"];

    this.dataCrs     = null;    // CRSs that the data is available in (will be a list)
    this.dataBbox    = null;    // Projected bounds of the WFS dataset, if any

    this.dataCrs  = datasetInfo.srs || (datasetInfo.supportedCRS  && datasetInfo.supportedCRS[0]) ||
                                       (datasetInfo.supportedCRSs && datasetInfo.supportedCRSs[0]);

    // With WFS, latLongBoundingBox is really a projected bbox... the name is misleading.  Thouugh on some
    // servers, it is misimpelmented, and we will get a real lat-long bbox here.  In those cases... well...
    // the data will be bogus.  Garbage in, garbage out.
    this.dataBbox = datasetInfo.bounds;  
  };

  WFSDataset.prototype = new Dataset;
  WFSDataset.prototype.constructor = WFSDataset; // repair the inherited constructor


  // This gets called in response to both a GetCapabilites and a DescribeCoverage response
  // request is just a string that we can use for debugging
  var WCSDataset = function(serverUrl, datasetInfo, request)
  {
    Dataset.call(this, serverUrl, datasetInfo);

    this.type = ["WCS"];
    
    // Only available on a DescribeCoverage response
    if(datasetInfo.nativeCRS)
    {
      this.dataCrs = new Array();
      while (crs = datasetInfo.supportedCRSs.pop()) 
      	this.dataCrs.push(CRS.getSimpleFormat(crs))
    }
    
    try
    {
    	this.dataBbox = datasetInfo.domain.spatialDomain.boundingBoxes["urn:x-ogc:def:crs:EPSG::4326"];
	}
	catch(e)
	{
	    if(datasetInfo.bounds) this.dataBbox = datasetInfo.bounds;
	}

    try {
      // Use image/img if it is available... seems to work best
      if(datasetInfo.supportedFormats.hasObject("image/img"))
        this.format = "image/img";
      else if(datasetInfo.supportedFormats.hasObject("image/tiff"))
        this.format = "image/tiff";
      else
        this.format = datasetInfo.supportedFormats[0];
    } catch(error) {
      // Do nothing
    }

    if(datasetInfo.domain && 
      datasetInfo.domain.spatialDomain && 
      datasetInfo.domain.spatialDomain.gridCRS && 
      datasetInfo.domain.spatialDomain.gridCRS.gridOffsets)
    {
      this.resolution = datasetInfo.domain.spatialDomain.gridCRS.gridOffsets;
    }
  };

  WCSDataset.prototype = new Dataset;
  WCSDataset.prototype.constructor = WCSDataset; // repair the inherited constructor


  // Gets run on any layer found, registered or not; dataset is a Dataset object
  // Merges dataset into the already created layer record, if it exists
  var mergeDatasetIntoLayerList = function(dataset, service)
  {
    // Need a single key to make iteration elsewhere easier
    var key = cssEscape(dataset.serverUrl + dataset.identifier);   

    var layer = discoveredLayers[key];

    // It's a new layer, add it to discoveredLayers without further ado
    if(!layer) {   
      discoveredLayers[key] = dataset;
      layer = dataset;
    }

    else {   // Already found this layer, add service to it
      // We'll get here twice with service == WCS; we don't want to list it twice in layer.type
      // layer.type is a list of strings: "WCS", "WFS", and/or "WMS"
      if(!layer.type.hasObject(service))
        layer.type.push(service);

      if(service == "WFS") {
        layer.dataCrs  = dataset.dataCrs;
        layer.dataBbox = dataset.dataBbox;
      }
      else if(service == "WCS") {
        // We come through here twice... don't overwrite a valid
        // value with something that may be empty.
        if(!layer.dataCrs)
          layer.dataCrs = dataset.dataCrs;
        if(!layer.format)
          layer.format = dataset.format;
        if(!layer.resolution)
          layer.resolution = dataset.resolution;
        if(!layer.dataBbox)
          layer.dataBbox = dataset.dataBbox;
      }

      else if(service == "WMS")
      {
        layer.wmsCrs      = dataset.wmsCrs;
        layer.wmsCrsList  = dataset.wmsCrsList
        layer.mapBbox     = dataset.mapBbox;
        
        // Title and abstract from WMS supercede those from other services
        layer.title       = dataset.title;         
        layer["abstract"] = dataset["abstract"];
      }
    }
  };


  var RegisteredDatasetList = null;
  var CurrentServerUrl = null;

  var gotRegisteredDatasetList = function(url, datasetList)
  {
    // Make sure this request is for the current URL of interest
    if(url != CurrentServerUrl)
      return;

    eval("RegisteredDatasetList =" +  datasetList);

    // Call doneProcessing in case we're the last request to arrive
    doneProcessing("RegisteredDatasets", null);
  };


  var getResisteredDatasets = function(url)
  {
    RegisteredDatasetList = null;

    $.ajax({
      type: "GET",
      url:  "<%= url_for(:controller=>:datasets, :action=>:dataset_query, :format=>:json) %>",
      data: "server_url=" + url.replace(/[\\]/g, '%5C'),
      headers: { "X-CSRF-Token": "<%= form_authenticity_token.to_s %>" },
      success: function(data, status, jqXHR)  { 
          gotRegisteredDatasetList(url, data.datasets);
        },
      error: function(jqXHR, textStatus, error) { 
                 ajaxErrorHandler(jqXHR, status, error, "Could not get registered dataset list from iGUESS!");
                }
    });
  }; 


  // Tracks data about a server that we might want to display on the page
  var ServerInfo = function(title, abstract, owner)
  {
    this.title    = title;
    this.abstract = abstract;
    this.owner    = owner;
  };


  // Try to determine if capabilities represents an error or other negative response
  var isError = function(capabilities)
  {
    if(capabilities.error && capabilities.error.exceptionReport) {
      console.log("Error: ", capabilities);
      return true;
    }

    return false;
  };


  var processIncomingWMSLayers = function(capabilities, serverUrl)
  {
    if(!isError(capabilities)) {

      for(var i = 0, len = capabilities.capability.layers.length; i < len; i++)
      {
        var dataset = new WMSDataset(serverUrl, capabilities.capability.layers[i]);

        mergeDatasetIntoLayerList(dataset, "WMS");
      }

      var owner = "";

      if(capabilities.service && 
         capabilities.service.contactInformation && 
         capabilities.service.contactInformation.personPrimary &&
         capabilities.service.contactInformation.personPrimary.organization)
      {
        owner = capabilities.service.contactInformation.personPrimary.organization;
      }

      var serverInfo = new ServerInfo(capabilities.service.title, 
                                      capabilities.service["abstract"],
                                      owner);
    }

    doneProcessing("WMS", serverInfo);
  };


  var processIncomingWFSLayers = function(capabilities, serverUrl)
  {
    for(var i = 0, len = capabilities.featureTypeList.featureTypes.length; i < len; i++)
    {
      var dataset = new WFSDataset(serverUrl, capabilities.featureTypeList.featureTypes[i]);

      mergeDatasetIntoLayerList(dataset, "WFS");
    }

    // WFS 1.0.0 seems not to return server owner details
    var serverInfo = new ServerInfo(capabilities.serviceIdentification.title, 
                                    capabilities.serviceIdentification.abstract);

    doneProcessing("WFS", serverInfo);
  };


  // Class declaration -- maintain same public interface as ServiceProbe on register WPS server page
  // :::constructor:::
  var ServiceProbe = function(serverUrl) 
  {   
    this.serverUrl = serverUrl;
    var self       = this;    // Stored pointer to ourselves, will be needed in the callback
  

    // :::public:::
    this.startProbing = function() 
    { 
      WMS.getCapabilities(self.serverUrl,  self.onWmsGetCapabilitiesSucceeded);
      WFS.getCapabilities(self.serverUrl,  self.onWfsGetCapabilitiesSucceeded);
      // Launch both GetCapabilities and DescribeCoverage requests:
      WCS.getCapabilities(self.serverUrl,  self.onWcsGetCapabilitiesSucceeded);  

      CurrentServerUrl = self.serverUrl;    // For external access... can we do this a better way?
      getResisteredDatasets(self.serverUrl); 
    };

    // :::private:::
    // TODO: If capabilities is undefined, there was a problem somewhere... it should be logged
    this.onWfsGetCapabilitiesSucceeded = function(capabilities, response) {
      if(capabilities && isGoodResponse("WFS", response, capabilities))
        processIncomingWFSLayers(capabilities, self.serverUrl);
      else    // Error:
        doneProcessing("WFS", null);
    };

    this.onWmsGetCapabilitiesSucceeded = function(capabilities, response) {
      if(capabilities && isGoodResponse("WMS", response, capabilities))
        processIncomingWMSLayers(capabilities, self.serverUrl);
      else    // Error:
        doneProcessing("WMS", null);
    };

    this.onWcsGetCapabilitiesSucceeded = function(capabilities, response) {
      if(capabilities && isGoodResponse("WCS", response, capabilities))
        processIncomingWCSLayers(capabilities, self.serverUrl);
      else    // Error:
        doneProcessing("WCS", null); 
    };
  }


  // Build a ServerInfo object from capabilities... if it has the necessary data.
  // Will return null if we don't have any data.
  var getServerInfo = function(capabilities)
  {
    var title    = "";
    var abstr    = "";
    var provider = "";
    var ok = false;

    if(capabilities.serviceIdentification) {
      title = capabilities.serviceIdentification.title || "Just Another Unnamed Server";
      abstr = capabilities.serviceIdentification["abstract"] || "";
      ok = true;
    }

    if(capabilities.serviceProvider)
    {
      provider = capabilities.serviceProvider.providerName || "";
      ok = true;
    }

    if(ok)
      return new ServerInfo(title, abstr, provider);
    else
      return null;
  };


  // capabilities could contain responses from either GetCapabilities or DescribeCoverage
  var processIncomingWCSLayers = function(capabilities, serverUrl)
  {
    var serverInfo = null;

    // WCSDescribeCoverage requests return a dictionary rather than an array, as the other services do
    if(capabilities.requestType == "WCSDescribeCoverage") {
      var coverageKeys = capabilities.coverageDescriptionKeys;

      // Some servers return a husk of a response with no data in coverageDescriptionKeys
      if(coverageKeys)
        for(var i = 0, len = coverageKeys.length; i < len; i++) {
          var dataset = new WCSDataset(serverUrl, capabilities.coverageDescriptions[coverageKeys[i]], "WCSDescribeCoverage");
          mergeDatasetIntoLayerList(dataset, "WCS");
        }
    }
    else {   // WCSGetCapabilities
      if(capabilities.contentMetadata) {
        var coverageList = capabilities.contentMetadata;

        for(var i = 0, len = coverageList.length; i < len; i++) {
          var dataset = new WCSDataset(serverUrl, coverageList[i], "WCSGetCapabilities");
          mergeDatasetIntoLayerList(dataset, "WCS");
        }
        serverInfo = getServerInfo(capabilities);   // Could return null
      }
    }

    doneProcessing("WCS", serverInfo);
  };  

</script>

