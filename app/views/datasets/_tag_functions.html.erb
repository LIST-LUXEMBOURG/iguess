<%# This function builds a list of data layers that are registered, and are thus stored in the database.
    Layers are actually objects with a type and rubyId field.  Display name should come from the data server itself, and will
      be retrieved separately %>

<script type="text/javascript">

  var deleteTagClickHandler = function(ctrl)
  {
    var serverUrl         = ctrl.data('url');
    var datasetIdentifier = ctrl.data('identifier');
    var tagVal            = ctrl.parent().text().trim();
    
    if(confirmDeleteTag(serverUrl, datasetIdentifier, tagVal))
      deleteTag(serverUrl, datasetIdentifier, tagVal);
  };


  var deleteFolderTagClickHandler = function(ctrl)
  {
    // We don't ask for a confirmation here...
    deleteFolderTag(ctrl.data('url'), 
                    ctrl.data('identifier'), 
                    ctrl.parent().text().trim());
  };


  // Take an array or comma-separated list of tags and format them into some presentation quality HTML
  var createTagList = function(taglist, deletable, serverUrl, datasetIdentifier, tagclass) 
  {
      if(taglist.length == 0)
        return "";

      if(typeof(taglist) == "string")
        taglist = taglist.split(",");

      var delBtn = "";

      if(deletable)   // or folder-tag-delete-button
        delBtn = '<span class="' + tagclass + '-delete-button" ' +
                 'data-url="' + serverUrl + '" ' +
                 'data-identifier="' + datasetIdentifier + '"></span>';

      var renderedList = "";
      var strings = typeof(taglist[0]) == "string";

      for(var i = 0, len = taglist.length; i < len; i++) 
        renderedList += '<span class="' + tagclass + '">' + delBtn +
                         (strings ? taglist[i] : taglist[i].tag) + '</span> ';  // Trailing space required

     return renderedList; 
  };


  var addDeleteTagClickHander = function(isProcessingTag) 
  {
    // Add a handler to delete tags when clicked on
    if(isProcessingTag)
      $('.tag-delete-button')       .on('click', function(event){ deleteTagClickHandler($(this)) });
    else
      $('.folder-tag-delete-button').on('click', function(event){ deleteFolderTagClickHandler($(this)) });
  };


  // This will update any tag lists composed of tags that do have a delete control, such as 
  // the tags entries on the dataset info popups.  Note that we do not combine folder tags and
  // processing tags, and do want to add a 'No Tags' placeholder if the list is empty.
  var doUpdateDeleteableTags = function(serverUrl, datasetIdentifier, id, tags, tagclass)
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    $('.' + id + '-deletable-' + urlId).html(
          createTagList(tags, true, serverUrl, datasetIdentifier, tagclass));

    addDeleteTagClickHander(tagclass == 'tag');
  };


  // This will update any tag lists composed of tags that do not have a delete control, such as 
  // the Tags column of the Registered Datasets screen.  Note that we combine folder tags and
  // processing tags, and do not want to add a 'No Tags' placeholder if the list is empty.
  var doUpdateNonDeleteableTags = function(serverUrl, datasetIdentifier, id, tags, tagclass)
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    $('.' + id + '-' + urlId).html(
          createTagList(tags, false, serverUrl, datasetIdentifier, tagclass));
  };


  var updateTags = function(serverUrl, datasetIdentifier, tags)
  {
    doUpdateDeleteableTags   (serverUrl, datasetIdentifier, 'taglist', tags, 'tag');
    doUpdateNonDeleteableTags(serverUrl, datasetIdentifier, 'taglist', tags, 'tag');
  };


  var updateFolderTags = function(serverUrl, datasetIdentifier, tags)
  {
    doUpdateDeleteableTags   (serverUrl, datasetIdentifier, 'folder-taglist', tags, 'folder-tag');
    doUpdateNonDeleteableTags(serverUrl, datasetIdentifier, 'folder-taglist', tags, 'folder-tag');
  };


  var tagPickerChanged = function(ctrl)
  {
    ctrl.blur();    // For firefox?

    if(ctrl.val() === 'Ignore This') 
      return; 

    addTag(ctrl);
  };


  // TODO: This should really be computed server-side, and should only consider config datasets that we control
  TagIsInUse = {};
  <%= raw @datasets.map{ |d| 
          d.config_datasets.map{ |c| 'if(!TagIsInUse["' + c.input_identifier + '"])' +
                                     '  TagIsInUse["' + c.input_identifier + '"] = {};' + 
                                     'if(!TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")]) ' +
                                     '  TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")] = 0;' +
                                     'TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")]++;'
                              }
                      }.join(' ');
  %>   


  var confirmDeleteTag = function(serverUrl, datasetIdentifier, tagVal) 
  {
    if(TagIsInUse[tagVal] && TagIsInUse[tagVal][cssEscape(serverUrl + datasetIdentifier)] > 0) {
      var ct = TagIsInUse[tagVal][cssEscape(serverUrl + datasetIdentifier)];
      var c  = (ct == 1) ? "configuration" : "configurations";
      var t  = (ct == 1) ? "this"          : "these";
      var th = (ct == 1) ? "it"            : "them";

      return confirm("This dataset is in use by " + ct + " " + c + ". " +
                     "Changing its type will cause it to be removed from " + t + " " + c + ".\n\n" +
                     "Click OK if you are sure you want to change the type of this dataset.");
    }
    // else...
    return true;
  };



  // General handler for json requests that return an unexpected error
  var jsonErrorHandler = function(jqXHR, status, error, msg)
  {
    // Often, if we encounter a rails error, jqXHR.status will be 500.  Show that error
    // in a new window because responseText will contain a full HTML document.
    if(jqXHR.status == 500)
    {
      var win = window.open();
      if(win)
      {
        $(win.document.body).html(jqXHR.responseText);
        return;
      }

      // Can't open window... thorow this up as a last ditch effort to report the error
      alert(msg + "  Can't open window... got error: " + jqXHR.responseText + '")');
      return;
    }

    
    alert(msg + ' (server says: "' + jqXHR.responseText + '")');
  };



  // tagType will be true for regular tags, false for folder-tags
  var doAddTag = function(ctrl, tagType, successFunction)
  {

    var url = tagType ? '<%= url_for(:controller => 'datasets', :action => 'add_data_tag') %>' :
                        '<%= url_for(:controller => 'datasets', :action => 'add_data_folder_tag') %>'

    var datasetIdentifier = ctrl.data('datasetidentifier');
    var serverUrl         = ctrl.data('serverurl');

    // Let the server know the dataType has changed
    var tag = ctrl.val();

    $.ajax({
      type:    'PUT',      // PUT combined with url below triggers "update" action on controller
      url:     url,
      data:    'dataset[identifier]='  + datasetIdentifier +
               '&dataset[server_url]=' + serverUrl +
               '&tag_val='             + tag,
      headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' /*,
                 'Content-Type': 'application/json' */},
      success: function(data) { successFunction(serverUrl, datasetIdentifier, eval(data)); },
      error:   function(jqXHR, status, error) { 
                  jsonErrorHandler(jqXHR, status, error, "Could not add tag!");
               }
    });
  };


  // User adds or removes a tag
  var addTag = function(ctrl)
  {
    doAddTag(ctrl, true, updateTags);
  };


  // User adds or removes a tag
  var addFolderTag = function(ctrl)
  {
    doAddTag(ctrl, false, updateFolderTags);
  };


  // tagType will be true for regular tags, false for folder-tags
  var doDeleteTag = function(datasetIdentifier, serverUrl, tagValue, tagType, successFunction)
  {
    $.ajax({
      type:    'PUT',      // PUT combined with url below triggers "update" action on controller
      url:     '<%= url_for(:controller => "datasets", :action => "del_tag") %>',
      data:    'dataset[identifier]='  + datasetIdentifier +
               '&dataset[server_url]=' + serverUrl +
               '&tag_type='            + (tagType ? 'proc' : 'folder') +
               '&tag_val='             + tagValue,
      headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' /*,
                 'Content-Type': 'application/json' */},
      success: function(data) { successFunction(serverUrl, datasetIdentifier, eval(data)); },
      error:   function(jqXHR, status, error) { 
                  jsonErrorHandler(jqXHR, status, error, "Could not delete tag!");
               }
    });
  };


  var deleteTag = function(serverUrl, datasetIdentifier, tagValue)
  {
    doDeleteTag(datasetIdentifier, serverUrl, tagValue, true, updateTags);
  };


  var deleteFolderTag = function(serverUrl, datasetIdentifier, tagValue)
  {
    doDeleteTag(datasetIdentifier, serverUrl, tagValue, false, updateFolderTags);
  };


  // Dict to keep track of user added folder tags 
  var tagLists = {};


  var resizeInputField = function(fieldName)
  {
    // Resize input field to fit neatly inside the fake input box
    var input = $('#input-' + fieldName);

    var width = input.parent().width() - input.prevAll().width();

    // If resulting width is too small, bump it up to a min size
    if(width < 50)
      width = 50;

    input.width(width);
    input.parent().scrollLeft(99999);
  };


  var addFolderTagXXX = function(fieldName, tag, rebuilding)
  {
    if(tag === "")
      return;

    if(!tagLists[fieldName])
      tagLists[fieldName] = [];

    // Check if we already have the tag... don't add it twice!
    if(!rebuilding)
    {
      var index = tagLists[fieldName].indexOf(tag);
      if(index > -1)
        return;    

      tagLists[fieldName].push(tag);
    }

    // Trailing space required below!
    var tagCode = "<span class='folder-tag'>" + 
                    "<span class='folder-tag-delete-button' " +
                          "onclick='delTagXXX(\"" + fieldName + "\",\"" + tag + "\"); return false;'></span>" + 
                  tag + "</span> "; 

    $('span[name="tags-' + fieldName + '"]').append(tagCode);  

    if(!rebuilding)
      resizeInputField(fieldName);
  };


  var delTagXXX = function(fieldName, tag)
  {
    var index = tagLists[fieldName].indexOf(tag);
    if(index > -1)
      tagLists[fieldName].splice(index, 1);

    // Rebuild tag list without the deleted tag
    $('span[name="tags-' + fieldName + '"]').empty();
    for(var i=0, len=tagLists[fieldName].length; i < len; i++)
      addFolderTagXXX(fieldName, tagLists[fieldName][i], true);

    resizeInputField(fieldName);
  };


  // fieldName looks like "tagEntry8"
  var clearTagMatchCandidateList = function(fieldName)
  {
    $('#matches-' + fieldName).empty();
    $('#matches-' + fieldName).hide();
  };


  var folderTagMatchCandidateClicked = function(fieldName, tag)
  {
    addFolderTagXXX(fieldName, tag, false);   
    clearTagMatchCandidateList(fieldName);
    $('#input-' + fieldName).val("");   // Remove any partially typed tags
  };


  // Show the list of possible tag matches.  Matches will be shown as tags that can be clicked to complete
  // a partially typed tag.
  var showTagMatches = function(fieldName, tagList)
  {
    if(tagList === "") {
      clearTagMatchCandidateList(fieldName);
      return;
    }

    var matchList = "";

    for(var tag; tag = tagList.pop();) {

      // Skip matches that are in use here
      if(tagLists[fieldName] && tagLists[fieldName].hasObject(tag))
        continue;

      var code = 'folderTagMatchCandidateClicked("' + fieldName + '", "' + tag + '"); return false;';
      matchList += "<span class='folder-tag clickable' onclick='" + code + "'>" + tag + "</span> ";  // Trailing space required
    }

    console.log(":ML: ",matchList);

    $('#matches-' + fieldName).html("Possible matches:<br>" + matchList);
    $('#matches-' + fieldName).show();
  };


  // Handles success callback from findMatchingTags
  var foundMatchingTags = function(jqXHR)
  {
    var fieldName    = jqXHR.data[0].fieldname;
    var matchingTags = jqXHR.data[0].matching_tags;

    showTagMatches(fieldName, matchingTags);
  };


  // Check if we already have a dataset with this name; tagFragment should always have some value
  var findMatchingTags = function(tagFragment, fieldName)
  {
    var serverUrl = '<%= url_for(:controller => "datasets", :action => "find_matching_tags", :format => :json) %>';
    $.ajax({
        type: 'GET',
        url: serverUrl,
        data: 'prefix=' + tagFragment + '&field_name=' + fieldName,
        headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' },
        success: foundMatchingTags,
        error: function(jqXHR, textStatus, error) { jsonErrorHandler(jqXHR, status, error, "Error looking for tags!"); }
      });
  }


  var onFolderTagEntryChanged = function(field) 
  { 
    var words = field.value.split(" ");

    // Last word will be "" when field.value ends with a space, so
    // user has ended a word and we should add the tag
    if(field.value !== "" && words[words.length - 1] === "") {
      addFolderTagXXX(field.name, words[words.length - 2], false);
      field.value = "";
      clearTagMatchCandidateList(field.name);
    }

    // field.value does not end in space, so still typing a word
    else if(words[words.length - 1] !== "")
      findMatchingTags(words[words.length - 1], field.name);

    // Otherwise, field must be empty
    else
      showTagMatches(field.name, "");
  }

</script>
